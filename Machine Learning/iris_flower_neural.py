# -*- coding: utf-8 -*-
"""Iris_flower_neural.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Epw52kRp6XQ4lOk0aPoVJjukxWyjc9Ch
"""

import torch
import torch.nn as nn
import torch.nn.functional as f

class Model(nn.Module):
  def __init__(self, inp_features=4, h1=8, h2=9, out_features=3):
    super().__init__()
    self.fc1= nn.Linear(inp_features,h1)
    self.fc2= nn.Linear(h1,h2)
    self.out= nn.Linear(h2,out_features)

  def forward(self,x):
    x=f.relu(self.fc1(x))
    x=f.relu(self.fc2(x))
    x=self.out(x)
    return x

torch.manual_seed(41)
model= Model()

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

url='https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/0e7a9b0a5d22642a06d3d5b9bcbad9890c8ee534/iris.csv'
df= pd.read_csv(url)

df.head()

#df['variety']=df['species']
df['variety']=df['species'].map({'setosa':0.0,'versicolor':1.0,'virginica':2.0})

df

X=df.drop(['variety','species'], axis=1,)
y=df['variety']

X=X.values
y=y.values

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test= train_test_split(X,y,test_size=0.2,random_state=41)

X_train=torch.FloatTensor(X_train)
X_test=torch.FloatTensor(X_test)
y_train=torch.LongTensor(y_train)
y_test=torch.LongTensor(y_test)

criterion= nn.CrossEntropyLoss()
optimizer= torch.optim.Adam(model.parameters(), lr=0.01)

model.parameters

epochs=100
losses= []
for i in range(epochs):
  y_pred= model.forward(X_train)
  loss= criterion(y_pred, y_train)
  losses.append(loss)

  if i%10==0:
    print(f'Epoch: {i} Loss: {loss}')

  optimizer.zero_grad()
  loss.backward()
  optimizer.step()

plt.plot(range(epochs), [loss.detach().numpy() for loss in losses])
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.show()

with torch.no_grad():
  y_eval= model.forward(X_test)
  loss= criterion(y_eval, y_test)

loss

from math import e
correct = 0
with torch.no_grad():
  for i, data in enumerate(X_test):
    y_val= model.forward(data)


    if y_test[i]==0:
      x= 'Setosa'
    elif y_test[i]==1:
      x= 'Versicolor'
    else:
      x= 'Virginica'


    if y_val.argmax().item()==0:
      t= 'Setosa'
    elif y_test[i]==1:
      t= 'Versicolor'
    else:
      t= 'Virginica'


    print(f'{i+1:2}. {str(y_val):38}    {x}             {t}')

    if y_val.argmax().item()== y_test[i]:
      correct+=1
print(f'\n{correct} out of {len(y_test)} = {100*correct/len(y_test):7.2f}% correct')

new_iris= torch.tensor([4.7,3.2,1.3,.2])

with torch.no_grad():
  pred= model.forward(new_iris)
  print(pred.argmax().item())

new_iris= torch.tensor([5.9,3.0,5.1,1.82])

with torch.no_grad():
  pred= model.forward(new_iris)
  print(pred.argmax().item())

torch.save(model.state_dict(), 'my_iris_model.pt')

new_model= Model()
new_model.load_state_dict(torch.load('my_iris_model.pt'))

new_model.eval()

